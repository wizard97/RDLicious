// NOTE: This is a partial translation of the SystemRDL.g4 grammar to LALRPOP.
// It focuses on the high-level structure needed by the current tests:
//  - Root containing a list of component or enum definitions terminated by ';'
//  - Component named definitions with an (empty) body
//  - Enum definitions with entries
//  - A very small expression grammar (currently just numeric literals or IDs)
// The intent is to extend this incrementally to cover more of SystemRDL.

grammar;

use crate::ast::*;

// ---------------------------- LEXER ---------------------------------------
match {
    // Numbers (decimal & hex)
    r"[0-9]+" => INT,
    r"0x[0-9a-fA-F]+" => HEX_LOW,
    r"0X[0-9a-fA-F]+" => HEX_UPPER,

    // Identifiers
    r"[a-zA-Z_][a-zA-Z0-9_]*" => ID,

    // Keywords we currently distinguish explicitly
    "addrmap",
    "regfile",
    "reg",
    "field",
    "mem",
    "enum",

    // Operators & punctuation used so far
    "**",
    "<<",
    ">>",
    "==",
    "!=",
    "<=",
    ">=",
    "&&",
    "||",
    "=",
    "[",
    "]",
    "@",
    "{",
    "}",
    ";",
    ",",
    "(",
    ")",
    "?",
    ":",
    "+",
    "-",
    "*",
    "/",
    "%",
    "&",
    "|",
    "^",
    "~^",
    "^~",
    "!",
    "~",
    "<",
    ">",

    // Whitespace & comments
    r"[ \t\r\n]+" => { },
    r"//[^\n\r]*" => { },
    r"/\*([^*]*\*+[^*/])*([^*]*\*+|[^*])*\*/" => { },
    r#"\"([^"\\]|\\.)*\""# => STRING,
    _
}

// ---------------------------- AST TYPES -----------------------------------

// AST definitions live in ast.rs. Here we just build them.

// ---------------------------- PARSER RULES --------------------------------

Ident: String = {
    <s:ID> => s.to_string(),
};

Number: String = {
    <s:INT> => s.to_string(),
    <s:HEX_LOW> => s.to_string(),
    <s:HEX_UPPER> => s.to_string(),
};

String: String = { <s:STRING> => s.to_string() };

pub Expr: Expr = Ternary;

Ternary: Expr = {
    <c:LogicOr> "?" <t:Expr> ":" <e:Expr> => Expr::Ternary { cond: Box::new(c), then_br: Box::new(t), else_br: Box::new(e) },
    LogicOr => <>,
};

LogicOr: Expr = {
    <l:LogicOr> "||" <r:LogicAnd> => Expr::Binary { op: "||".into(), lhs: Box::new(l), rhs: Box::new(r) },
    LogicAnd => <>,
};

LogicAnd: Expr = {
    <l:LogicAnd> "&&" <r:BitOr> => Expr::Binary { op: "&&".into(), lhs: Box::new(l), rhs: Box::new(r) },
    BitOr => <>,
};

BitOr: Expr = {
    <l:BitOr> "|" <r:BitXor> => Expr::Binary { op: "|".into(), lhs: Box::new(l), rhs: Box::new(r) },
    BitXor => <>,
};

BitXor: Expr = {
    <l:BitXor> "^" <r:BitAnd> => Expr::Binary { op: "^".into(), lhs: Box::new(l), rhs: Box::new(r) },
    <l:BitXor> "~^" <r:BitAnd> => Expr::Binary { op: "~^".into(), lhs: Box::new(l), rhs: Box::new(r) },
    <l:BitXor> "^~" <r:BitAnd> => Expr::Binary { op: "^~".into(), lhs: Box::new(l), rhs: Box::new(r) },
    BitAnd => <>,
};

BitAnd: Expr = {
    <l:BitAnd> "&" <r:Equality> => Expr::Binary { op: "&".into(), lhs: Box::new(l), rhs: Box::new(r) },
    Equality => <>,
};

Equality: Expr = {
    <l:Equality> "==" <r:Relational> => Expr::Binary { op: "==".into(), lhs: Box::new(l), rhs: Box::new(r) },
    <l:Equality> "!=" <r:Relational> => Expr::Binary { op: "!=".into(), lhs: Box::new(l), rhs: Box::new(r) },
    Relational => <>,
};

Relational: Expr = {
    <l:Relational> "<" <r:Shift> => Expr::Binary { op: "<".into(), lhs: Box::new(l), rhs: Box::new(r) },
    <l:Relational> "<=" <r:Shift> => Expr::Binary { op: "<=".into(), lhs: Box::new(l), rhs: Box::new(r) },
    <l:Relational> ">" <r:Shift> => Expr::Binary { op: ">".into(), lhs: Box::new(l), rhs: Box::new(r) },
    <l:Relational> ">=" <r:Shift> => Expr::Binary { op: ">=".into(), lhs: Box::new(l), rhs: Box::new(r) },
    Shift => <>,
};

Shift: Expr = {
    <l:Shift> "<<" <r:Add> => Expr::Binary { op: "<<".into(), lhs: Box::new(l), rhs: Box::new(r) },
    <l:Shift> ">>" <r:Add> => Expr::Binary { op: ">>".into(), lhs: Box::new(l), rhs: Box::new(r) },
    Add => <>,
};

Add: Expr = {
    <l:Add> "+" <r:Mul> => Expr::Binary { op: "+".into(), lhs: Box::new(l), rhs: Box::new(r) },
    <l:Add> "-" <r:Mul> => Expr::Binary { op: "-".into(), lhs: Box::new(l), rhs: Box::new(r) },
    Mul => <>,
};

Mul: Expr = {
    <l:Mul> "*" <r:Unary> => Expr::Binary { op: "*".into(), lhs: Box::new(l), rhs: Box::new(r) },
    <l:Mul> "/" <r:Unary> => Expr::Binary { op: "/".into(), lhs: Box::new(l), rhs: Box::new(r) },
    <l:Mul> "%" <r:Unary> => Expr::Binary { op: "%".into(), lhs: Box::new(l), rhs: Box::new(r) },
    Unary => <>,
};

Unary: Expr = {
    "+" <u:Unary> => Expr::Unary { op: "+".into(), rhs: Box::new(u) },
    "-" <u:Unary> => Expr::Unary { op: "-".into(), rhs: Box::new(u) },
    "!" <u:Unary> => Expr::Unary { op: "!".into(), rhs: Box::new(u) },
    "~" <u:Unary> => Expr::Unary { op: "~".into(), rhs: Box::new(u) },
    Primary => <>,
};

Primary: Expr = {
    Number => Expr::Number(<>),
    Ident  => Expr::Ident(<>),
    String => Expr::Str(<>),
    "(" <e:Expr> ")" => e,
};

pub Root: Root = {
    <v:RootItems> => Root(v),
    => Root(vec![]),
};

RootItems: Vec<RootItem> = {
    <head:RootItem> ";" <tail:RootItems> => {
        let mut v = vec![head];
        v.extend(tail);
        v
    },
    <single:RootItem> ";" => vec![single],
};

RootItem: RootItem = {
    ComponentNamedDef => RootItem::Component(<>),
    EnumDef => RootItem::Enum(<>),
};

ComponentTypePrimary: ComponentTypePrimary = {
    "addrmap" => ComponentTypePrimary::Addrmap,
    "regfile" => ComponentTypePrimary::Regfile,
    "reg" => ComponentTypePrimary::Reg,
    "field" => ComponentTypePrimary::Field,
    "mem" => ComponentTypePrimary::Mem,
};

ComponentBody: () = {
    "{" (ComponentBodyItem ";")* "}" => (),
};

ComponentBodyItem: () = {
    AnonComponentWithInst => (),
    ComponentNamedDef => (),
    SimpleInst => (),
    PropertyAssign => (),
};

AnonComponentWithInst: () = { // e.g., reg { ... } reg_foo
    ComponentTypePrimary ComponentBody Ident InstSuffixes? InstAddr? => (),
};

SimpleInst: () = { // e.g., mem_mem mem_inst;
    ExtKw? Ident Ident InstSuffixes? InstAddr? => (),
};

ExtKw: () = { "external" => () };

InstSuffixes: () = { RangeSuffixes => () };
RangeSuffixes: () = { RangeSuffix RangeSuffixes => (), RangeSuffix => (), ArraySuffix RangeSuffixes => (), ArraySuffix => () };
RangeSuffix: () = { "[" Expr ":" Expr "]" => () };
ArraySuffix: () = { "[" Expr "]" => () };
InstAddr: () = { "@" Expr => () };

PropertyAssign: () = {
    Ident "=" Expr => (),
};

pub ComponentNamedDef: ComponentDef = {
    <t:ComponentTypePrimary> <n:Ident> <_b:ComponentBody> => ComponentDef { ctype: t, name: n },
};

EnumEntries: Vec<EnumEntry> = {
    <head:EnumEntry> <tail:EnumEntries> => {
        let mut v = vec![head];
        v.extend(tail); v
    },
    <last:EnumEntry> => vec![last],
};

EnumEntry: EnumEntry = {
    <n:Ident> "=" <e:Expr> ";" => EnumEntry { name: n, value: Some(e) },
    <n:Ident> ";" => EnumEntry { name: n, value: None },
};

pub EnumDef: EnumDef = {
    "enum" <n:Ident> "{" <ents:EnumEntries> "}" => EnumDef { name: n, entries: ents },
};
