grammar;

use crate::ast::*;

// Lexer: a pragmatic subset of SystemRDL tokens needed for the implemented grammar.
match {
    // Keywords and multi-char ops first so they are not lexed as generic ID
    "addrmap","regfile","reg","field","mem","enum","struct","abstract","default","external","internal","true","false","property","type","component","constraint","all","signal","alias",
    "**","<<",">>","==","!=","<=",">=","&&","||","~&","~|",
    "=","+=","%=","[","]","@","->","::","{","}",";",",",".","'","#",
    "(",")","?",":","+","-","*","/","%","&","|","^","~^","^~","!","~","<",">",
    r"[0-9]+" => INT,
    r"0x[0-9a-fA-F]+" => HEX_LOW,
    r"0X[0-9a-fA-F]+" => HEX_UPPER,
    r#"\"([^"\\]|\\.)*\""# => STRING,
    r"[a-zA-Z_][a-zA-Z0-9_]*" => ID,
    r"[ \t\r\n]+" => { },
    r"//[^\n\r]*" => { },
    r"/\*([^*]*\*+[^*/])*([^*]*\*+|[^*])*\*/" => { },
    _
}

Ident: String = {
    <s:ID> => s.to_string(),
};
Number: String = {
    <s:INT> => s.to_string(),
    <s:HEX_LOW> => s.to_string(),
    <s:HEX_UPPER> => s.to_string(),
};
String: String = {
    <s:STRING> => s.to_string(),
};

// Single-rule precedence-based expression grammar using attributes
pub Expr: Expr = {
    // Highest precedence: primary
    #[precedence(level="0")] Primary,
    // Unary prefix (right associative chaining)
    #[precedence(level="0")]
    "+" <e:Expr> => Expr::Unary { op: "+".into(), rhs: Box::new(e) },
    #[precedence(level="0")]
    "-" <e:Expr> => Expr::Unary { op: "-".into(), rhs: Box::new(e) },
    #[precedence(level="0")]
    "!" <e:Expr> => Expr::Unary { op: "!".into(), rhs: Box::new(e) },
    #[precedence(level="0")]
    "~" <e:Expr> => Expr::Unary { op: "~".into(), rhs: Box::new(e) },
    // Exponentiation (right associative)
    #[precedence(level="1")] #[assoc(side="right")]
    <l:Expr> "**" <r:Expr> => Expr::Binary { op: "**".into(), lhs: Box::new(l), rhs: Box::new(r) },
    // Multiplicative
    #[precedence(level="2")] #[assoc(side="left")]
    <l:Expr> "*" <r:Expr> => Expr::Binary { op: "*".into(), lhs: Box::new(l), rhs: Box::new(r) },
    #[precedence(level="2")] #[assoc(side="left")]
    <l:Expr> "/" <r:Expr> => Expr::Binary { op: "/".into(), lhs: Box::new(l), rhs: Box::new(r) },
    #[precedence(level="2")] #[assoc(side="left")]
    <l:Expr> "%" <r:Expr> => Expr::Binary { op: "%".into(), lhs: Box::new(l), rhs: Box::new(r) },
    // Additive
    #[precedence(level="3")] #[assoc(side="left")]
    <l:Expr> "+" <r:Expr> => Expr::Binary { op: "+".into(), lhs: Box::new(l), rhs: Box::new(r) },
    #[precedence(level="3")] #[assoc(side="left")]
    <l:Expr> "-" <r:Expr> => Expr::Binary { op: "-".into(), lhs: Box::new(l), rhs: Box::new(r) },
    // Shifts
    #[precedence(level="4")] #[assoc(side="left")]
    <l:Expr> "<<" <r:Expr> => Expr::Binary { op: "<<".into(), lhs: Box::new(l), rhs: Box::new(r) },
    #[precedence(level="4")] #[assoc(side="left")]
    <l:Expr> ">>" <r:Expr> => Expr::Binary { op: ">>".into(), lhs: Box::new(l), rhs: Box::new(r) },
    // Relational
    #[precedence(level="5")] #[assoc(side="left")]
    <l:Expr> "<" <r:Expr> => Expr::Binary { op: "<".into(), lhs: Box::new(l), rhs: Box::new(r) },
    #[precedence(level="5")] #[assoc(side="left")]
    <l:Expr> "<=" <r:Expr> => Expr::Binary { op: "<=".into(), lhs: Box::new(l), rhs: Box::new(r) },
    #[precedence(level="5")] #[assoc(side="left")]
    <l:Expr> ">" <r:Expr> => Expr::Binary { op: ">".into(), lhs: Box::new(l), rhs: Box::new(r) },
    #[precedence(level="5")] #[assoc(side="left")]
    <l:Expr> ">=" <r:Expr> => Expr::Binary { op: ">=".into(), lhs: Box::new(l), rhs: Box::new(r) },
    // Equality
    #[precedence(level="6")] #[assoc(side="left")]
    <l:Expr> "==" <r:Expr> => Expr::Binary { op: "==".into(), lhs: Box::new(l), rhs: Box::new(r) },
    #[precedence(level="6")] #[assoc(side="left")]
    <l:Expr> "!=" <r:Expr> => Expr::Binary { op: "!".into(), lhs: Box::new(l), rhs: Box::new(r) },
    // Bitwise AND
    #[precedence(level="7")] #[assoc(side="left")]
    <l:Expr> "&" <r:Expr> => Expr::Binary { op: "&".into(), lhs: Box::new(l), rhs: Box::new(r) },
    // Bitwise XOR variants
    #[precedence(level="8")] #[assoc(side="left")]
    <l:Expr> "^" <r:Expr> => Expr::Binary { op: "^".into(), lhs: Box::new(l), rhs: Box::new(r) },
    #[precedence(level="8")] #[assoc(side="left")]
    <l:Expr> "~^" <r:Expr> => Expr::Binary { op: "~^".into(), lhs: Box::new(l), rhs: Box::new(r) },
    #[precedence(level="8")] #[assoc(side="left")]
    <l:Expr> "^~" <r:Expr> => Expr::Binary { op: "^~".into(), lhs: Box::new(l), rhs: Box::new(r) },
    // Bitwise OR
    #[precedence(level="9")] #[assoc(side="left")]
    <l:Expr> "|" <r:Expr> => Expr::Binary { op: "|".into(), lhs: Box::new(l), rhs: Box::new(r) },
    // Logical AND
    #[precedence(level="10")] #[assoc(side="left")]
    <l:Expr> "&&" <r:Expr> => Expr::Binary { op: "&&".into(), lhs: Box::new(l), rhs: Box::new(r) },
    // Logical OR
    #[precedence(level="11")] #[assoc(side="left")]
    <l:Expr> "||" <r:Expr> => Expr::Binary { op: "||".into(), lhs: Box::new(l), rhs: Box::new(r) },
    // Ternary conditional (lowest precedence, right associative)
    #[precedence(level="12")] #[assoc(side="right")]
    <c:Expr> "?" <t:Expr> ":" <e:Expr> => Expr::Ternary { cond: Box::new(c), then_br: Box::new(t), else_br: Box::new(e) },
};

Primary: Expr = {
    EnumLit,
    StructLit,
    ArrayLit,
    BoolLit,
    Number => Expr::Number(<>),
    String => Expr::Str(<>),
    Ident  => Expr::Ident(<>),
    "(" <e:Expr> ")" => e,
};

EnumLit: Expr = {
    <s:Ident> "::" <n:Ident> => Expr::EnumLiteral { scope: s, name: n },
};
BoolLit: Expr = {
    "true" => Expr::Bool(true),
    "false" => Expr::Bool(false),
};
ArrayLit: Expr = {
    "'" "{" <elems:ArrayElems?> "}" => Expr::ArrayLiteral(elems.unwrap_or_default()),
};
ArrayElems: Vec<Expr> = {
    <h:Expr> "," <t:ArrayElems> => { let mut v=vec![h]; v.extend(t); v },
    <e:Expr> => vec![e],
};
StructLit: Expr = {
    <n:Ident> "'" "{" <kvs:StructKVs?> "}" => Expr::StructLiteral { name: n, kv: kvs.unwrap_or_default() },
};
StructKVs: Vec<(String, Expr)> = {
    <h:StructKV> "," <t:StructKVs> => { let mut v=vec![h]; v.extend(t); v },
    <one:StructKV> => vec![one],
};
StructKV: (String, Expr) = {
    <k:Ident> ":" <v:Expr> => (k, v),
};

// ---------------- Root and top-level items ---------------------------------
pub Root: Root = {
    <v:RootItems> => Root(v),
    => Root(vec![]),
};
RootItems: Vec<RootItem> = {
    <h:RootItem> ";" <t:RootItems> => { let mut v=vec![h]; v.extend(t); v },
    <s:RootItem> ";" => vec![s],
};
RootItem: RootItem = {
    ComponentNamedDef => RootItem::Component(<>),
    EnumDef => RootItem::Enum(<>),
    StructDef => RootItem::Struct(<>),
    DynPropAssign => RootItem::DynPropAssign(<>),
    LocalPropAssign => RootItem::LocalPropAssign(<>),
    UDPDef => RootItem::Udp(<>),
    ExplicitComponentInst => RootItem::ExplicitInst(<>),
    TopLevelSimpleInst => RootItem::ExplicitInst(<>),
};

// ---------------------------------------------------------------------------
// Explicit component instantiation (subset of full grammar, iterative build)
// Grammar reference (simplified):
//   explicit_component_inst ::= [ component_inst_type ] [ component_inst_alias ]
//                               ID component_insts
//   component_insts ::= [ param_inst ] component_inst { , component_inst }
//   component_inst ::= ID [ ( array+ | range ) ]
//                       [ = expr ] [ @ expr ] [ += expr ] [ %= expr ]
// We capture structural presence as booleans in SingleInst.

// Explicit component instantiation: require inst_type (external/internal) to avoid ambiguity
pub ExplicitComponentInst: ExplicitComponentInst = {
    "external" <a:InstAliasOpt> <base:Ident> <p:ParamInstOpt> <l:ExplicitInstList> => {
        ExplicitComponentInst { inst_type: Some("external".into()), alias: a, base, param_inst: p, instances: l }
    },
    "internal" <a:InstAliasOpt> <base:Ident> <p:ParamInstOpt> <l:ExplicitInstList> => {
        ExplicitComponentInst { inst_type: Some("internal".into()), alias: a, base, param_inst: p, instances: l }
    }
};
InstAliasOpt: Option<String> = { "alias" <id:Ident> => Some(id), => None };
ParamInstOpt: bool = { <_p:ParamInst> => true, => false };
ExplicitInstList: Vec<SingleInst> = {
    <h:ExplicitInstOne> "," <t:ExplicitInstList> => { let mut v=vec![h]; v.extend(t); v },
    <one:ExplicitInstOne> => vec![one],
};
ExplicitInstOne: SingleInst = {
    <n:Ident> <ar:InstArrayOrRange?> <ad:ExplicitAddr?> => { let (has_range, arrays)= ar.unwrap_or((false,0)); SingleInst { name:n, has_range, array_dims:arrays, has_init:false, has_addr:ad.unwrap_or(false), has_incr:false, has_mod:false } },
};
ExplicitAddr: bool = { "@" Expr => true };
InstArrayOrRange: (bool,u32) = { <_r:RangeSuffix> => (true,0), <n:ArraySuffixes1Plus> => (false,n) };
ArraySuffixes1Plus: u32 = { <_a:ArraySuffix> <rest:ArraySuffixes1Plus> => 1+rest, <_a:ArraySuffix> => 1 };

// (List / array / range handling to be added in later iterations.)

// Allow explicit component inst inside component bodies (discard AST):
ExplicitCompInstBody: () = { <_e:ExplicitComponentInst> => () };

ComponentTypePrimary: ComponentTypePrimary = {
    "addrmap" => ComponentTypePrimary::Addrmap,
    "regfile" => ComponentTypePrimary::Regfile,
    "reg" => ComponentTypePrimary::Reg,
    "field" => ComponentTypePrimary::Field,
    "mem" => ComponentTypePrimary::Mem,
};

ComponentBody: () = {
    "{" (ComponentBodyItem ";")* "}" => (),
};
ComponentBodyItem: () = {
    AnonComponentWithInst => (),
    ComponentNamedDef => (),
    SimpleInst => (),
    LocalPropAssign => (),
    DynPropAssign => (),
    ParamInst => (),
    ExplicitCompInstBody => (),
};
AnonComponentWithInst: () = {
    ComponentTypePrimary ComponentBody Ident InstSuffixes? InstAddr => (),
};
// Simple component instantiation inside component bodies (subset)
SimpleInst: () = {
    Ident Ident SimpleInstPost => (),
    Ident ParamInst Ident SimpleInstPost => (),
};
// external/internal handled only by ExplicitComponentInst to avoid ambiguity
InstSuffixes: () = {
    InstSuffix InstSuffixes => (),
    InstSuffix => (),
};
InstSuffix: () = {
    RangeSuffix => (),
    ArraySuffix => (),
};
RangeSuffix: () = {
    "[" Expr ":" Expr "]" => (),
};
ArraySuffix: () = {
    "[" Expr "]" => (),
};
SimpleInstPost: () = {
    RangeSuffix SimpleInstPost => (),
    ArraySuffix SimpleInstPost => (),
    "@" Expr => (),
    => (),
};
InstAddr: () = { ("@" Expr)? => () }; // retained for AnonComponentWithInst
// removed simple PropertyAssign to avoid ambiguity; LocalPropAssign handles '=' case

LocalPropAssign: LocalPropAssign = {
    "default" <p:Ident> "=" <e:Expr> => LocalPropAssign { is_default: true, prop: p, value: Some(e) },
    <p:Ident> "=" <e:Expr> => LocalPropAssign { is_default: false, prop: p, value: Some(e) },
};
DynPropAssign: DynPropAssign = {
    <t:InstanceRef> "->" <p:Ident> "=" <e:Expr> => DynPropAssign { target: t, prop: p, value: Some(e) },
};
InstanceRef: Vec<InstanceRefElem> = {
    <h:InstanceRefElem> <ts:InstanceRefTail*> => { let mut v=vec![h]; v.extend(ts); v },
};
InstanceRefTail: InstanceRefElem = {
    "." <e:InstanceRefElem> => e,
};
InstanceRefElem: InstanceRefElem = {
    <id:Ident> => InstanceRefElem { ident: id, array_suffixes: vec![] },
};

pub ComponentNamedDef: ComponentDef = {
    <t:ComponentTypePrimary> <n:Ident> <params:ParamDefOpt> <_b:ComponentBody> => ComponentDef { ctype: t, name: n, params },
};

// ---------------- Struct definitions (subset) -----------------------------
pub StructDef: StructDef = {
    <h:StructHeader> "{" <elems:StructElems?> "}" => StructDef { name: h.0, base: h.1, elems: elems.unwrap_or_default() },
};
StructHeader: (String, Option<String>) = {
    "struct" <n:Ident> ":" <b:Ident> => (n, Some(b)),
    "struct" <n:Ident> => (n, None),
    "abstract" "struct" <n:Ident> ":" <b:Ident> => (n, Some(b)),
    "abstract" "struct" <n:Ident> => (n, None),
};
StructElems: Vec<StructElem> = {
    <h:StructElem> <t:StructElems> => { let mut v=vec![h]; v.extend(t); v },
    <e:StructElem> => vec![e],
};
StructElem: StructElem = {
    <ty:Ident> <name:Ident> <arr:StructElemArray?> ";" => StructElem { ty, name, is_array: arr.is_some() },
};
StructElemArray: () = { "[" "]" => () };

// ---------------- User-defined properties (subset) -------------------------
UDPDef: UDPDef = {
    "property" <n:Ident> "{" <attrs:UDPAttrList> "}" => UDPDef { name: n, attrs },
};
UDPAttrList: Vec<UDPAttr> = {
    <h:UDPAttr> ";" <t:UDPAttrList> => { let mut v=vec![h]; v.extend(t); v },
    <a:UDPAttr> ";" => vec![a],
};
UDPAttr: UDPAttr = {
    "type" "=" <dt:Ident> <arr:UDPArray?> => UDPAttr::Type { data_type: dt, is_array: arr.is_some() },
    "default" "=" <e:Expr> => UDPAttr::Default(e),
    "component" "=" <ts:PropertyCompTypes> => UDPAttr::Usage(ts),
    "constraint" "=" <c:Ident> => UDPAttr::Constraint(c),
};
UDPArray: () = {
    "[" "]" => (),
};
PropertyCompTypes: Vec<String> = {
    <h:PropertyCompType> "|" <t:PropertyCompTypes> => { let mut v=vec![h]; v.extend(t); v },
    <one:PropertyCompType> => vec![one],
};
PropertyCompType: String = {
    "reg" => "reg".into(),
    "addrmap" => "addrmap".into(),
    "regfile" => "regfile".into(),
    "field" => "field".into(),
    "mem" => "mem".into(),
    "signal" => "signal".into(),
    "all" => "all".into(),
    "constraint" => "constraint".into(),
    <s:Ident> => s,
};

// ---------------- Parameters (subset) --------------------------------------
ParamDefOpt: Vec<ParamDecl> = {
    <p:ParamDef> => p,
    => vec![],
};
ParamDef: Vec<ParamDecl> = {
    "#" "(" <es:ParamDefElems> ")" => es,
};
ParamDefElems: Vec<ParamDecl> = {
    <v:ParamDefElemList> => v,
};
ParamDefElemList: Vec<ParamDecl> = {
    <h:ParamDefElem> <t:ParamDefElemListTail?> => { let mut v=vec![h]; if let Some(mut r)=t { v.append(&mut r);} v },
};
ParamDefElemListTail: Vec<ParamDecl> = {
    "," <n:ParamDefElem> <rest:ParamDefElemListTail?> => { let mut v=vec![n]; if let Some(mut r)=rest { v.append(&mut r);} v },
};
ParamDefElem: ParamDecl = {
    <dt:Ident> <name:Ident> ParamArrayType? <def:ParamDefault?> => ParamDecl { data_type: dt, name, default: def },
};
ParamArrayType: () = {
    "[" "]" => (),
};
ParamDefault: Expr = {
    "=" <e:Expr> => e,
};

// No longer need optional wrapper; handled in SimpleInst alternatives
ParamInst: () = {
    "#" "(" <ParamAssignments> ")" => (),
};
ParamAssignments: () = {
    <ParamAssignment> "," <ParamAssignments> => (),
    <ParamAssignment> => (),
};
ParamAssignment: () = {
    "." Ident "(" Expr ")" => (),
};

EnumEntries: Vec<EnumEntry> = {
    <h:EnumEntry> <t:EnumEntries> => { let mut v=vec![h]; v.extend(t); v },
    <l:EnumEntry> => vec![l],
};
EnumEntry: EnumEntry = {
    <n:Ident> "=" <e:Expr> ";" => EnumEntry { name: n, value: Some(e) },
    <n:Ident> ";" => EnumEntry { name: n, value: None },
};
pub EnumDef: EnumDef = {
    "enum" <n:Ident> "{" <ents:EnumEntries> "}" => EnumDef { name: n, entries: ents },
};
TopLevelSimpleInst: ExplicitComponentInst = {
    <base:Ident> <p:ParamInstOpt> <n:Ident> <ar:InstArrayOrRange?> <addr:TopLevelAddr?> => {
        let (has_range, arrays) = ar.unwrap_or((false,0));
        ExplicitComponentInst { inst_type: None, alias: None, base, param_inst: p, instances: vec![ SingleInst { name:n, has_range, array_dims:arrays, has_init:false, has_addr: addr.unwrap_or(false), has_incr:false, has_mod:false } ] }
    }
};
TopLevelAddr: bool = { "@" Expr => true };
